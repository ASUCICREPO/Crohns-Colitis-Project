{
    "AWSTemplateFormatVersion": "2010-09-09",
    "Description": "Amazon Q Business Integration with API Gateway and Lambda for Chat and Feedback",
    "Parameters": {
    "ApplicationId": {
      "Type":        "String",
      "Description": "Amazon Q Business Application ID (passed from CodeBuild)"
    }
  },
    "Resources": {
      "ConversationTable": {
        "Type": "AWS::DynamoDB::Table",
        "Properties": {
          "TableName": "ChatConversations",
          "BillingMode": "PAY_PER_REQUEST",
          "AttributeDefinitions": [
            {
              "AttributeName": "sessionId",
              "AttributeType": "S"
            }
          ],
          "KeySchema": [
            {
              "AttributeName": "sessionId",
              "KeyType": "HASH"
            }
          ],
          "TimeToLiveSpecification": {
            "AttributeName": "ttl",
            "Enabled": true
          }
        }
      },
      "AmazonQBusinessFunction": {
        "Type": "AWS::Lambda::Function",
        "Properties": {
          "FunctionName": "chatFunctionV2",
          "Handler": "index.handler",
          "Role": { "Fn::GetAtt": ["LambdaExecutionRole", "Arn"] },
          "Code": {
            "ZipFile": {
              "Fn::Sub": ["const { QBusinessClient, ChatSyncCommand } = require('@aws-sdk/client-qbusiness');\nconst { DynamoDBClient, PutItemCommand, GetItemCommand } = require('@aws-sdk/client-dynamodb');\n\nexports.handler = async (event) => {\n  try {\n    // Enable CORS\n    const headers = {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Headers\": \"Content-Type,X-Amz-Date,Authorization,X-Api-Key\",\n      \"Access-Control-Allow-Methods\": \"OPTIONS,POST\"\n    };\n    \n    // Handle preflight OPTIONS request\n    if (event.httpMethod === 'OPTIONS') {\n      return {\n        statusCode: 200,\n        headers,\n        body: ''\n      };\n    }\n    \n    // Parse request body\n    const body = JSON.parse(event.body);\n    const { message, conversationId, parentMessageId, sessionId } = body;\n    \n    console.log('Request body:', body);\n    \n    // Prepare parameters\n    const params = {\n      applicationId: \"${ApplicationId}\",\n      userMessage: message || body.userMessage\n    };\n    \n    if (conversationId) {\n      console.log(`Using conversation ID: ` + conversationId);\n      params.conversationId = conversationId;\n    }\n    \n    if (parentMessageId) {\n      console.log(`Using parent message ID: ` + parentMessageId);\n      params.parentMessageId = parentMessageId;\n    }\n    \n    // Validate required parameters\n    if (!params.applicationId) {\n      throw new Error('Application ID is required');\n    }\n    if (!params.userMessage) {\n      throw new Error('User message is required');\n    }\n    \n    console.log('Calling QBusiness API with params:', JSON.stringify(params));\n    \n    // Call QBusiness API\n    const client = new QBusinessClient({ region: \"us-west-2\" });\n    const cmd = new ChatSyncCommand(params);\n    const response = await client.send(cmd);\n    \n    console.log('Response received:', JSON.stringify(response));\n    \n    // Store conversation in DynamoDB if sessionId provided\n    if (sessionId) {\n      try {\n        const dynamoClient = new DynamoDBClient({ region: \"us-west-2\" });\n        const ttl = Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60); // 30 days\n        \n        // Get existing chat history\n        let chatHistory = [];\n        try {\n          const existingData = await dynamoClient.send(new GetItemCommand({\n            TableName: \"ChatConversations\",\n            Key: { sessionId: { S: sessionId } }\n          }));\n          if (existingData.Item && existingData.Item.chatHistory) {\n            chatHistory = JSON.parse(existingData.Item.chatHistory.S);\n          }\n        } catch (getError) {\n          console.log('No existing chat history found');\n        }\n        \n        // Add new messages to history\n        chatHistory.push({\n          type: 'USER',\n          message: message,\n          timestamp: Date.now()\n        });\n        chatHistory.push({\n          type: 'BOT',\n          message: response.systemMessage || '',\n          timestamp: Date.now(),\n          conversationId: response.conversationId,\n          systemMessageId: response.systemMessageId\n        });\n        \n        await dynamoClient.send(new PutItemCommand({\n          TableName: \"ChatConversations\",\n          Item: {\n            sessionId: { S: sessionId },\n            conversationId: { S: response.conversationId || \"\" },\n            lastSystemMessageId: { S: response.systemMessageId || \"\" },\n            chatHistory: { S: JSON.stringify(chatHistory) },\n            lastUpdated: { N: Date.now().toString() },\n            ttl: { N: ttl.toString() }\n          }\n        }));\n      } catch (dbError) {\n        console.error('DynamoDB error:', dbError);\n      }\n    }\n    \n    // Calculate confidence score based on response quality\n    let confidenceScore = 100;\n    \n    // Check if response indicates low confidence\n    const systemMessage = response.systemMessage || '';\n    const hasSourceAttributions = response.sourceAttributions && response.sourceAttributions.length > 0;\n    \n    // Lower confidence if no sources or generic responses\n    if (!hasSourceAttributions) {\n      confidenceScore -= 30;\n    }\n    \n    // Check for low confidence indicators in the message\n    const lowConfidenceIndicators = [\n      'no answer is found',\n      'i don\\'t have',\n      'i cannot find',\n      'no information',\n      'unable to provide',\n      'not sure',\n      'i\\'m sorry'\n    ];\n    \n    const messageText = systemMessage.toLowerCase();\n    const hasLowConfidenceIndicators = lowConfidenceIndicators.some(indicator => \n      messageText.includes(indicator)\n    );\n    \n    if (hasLowConfidenceIndicators) {\n      confidenceScore -= 50;\n    }\n    \n    // Ensure confidence is between 0-100\n    confidenceScore = Math.max(0, Math.min(100, confidenceScore));\n    \n    // Add confidence score to response\n    const enhancedResponse = {\n      ...response,\n      confidenceScore\n    };\n    \n    console.log('Enhanced response with confidence:', JSON.stringify(enhancedResponse));\n    \n    return {\n      statusCode: 200,\n      headers,\n      body: JSON.stringify(enhancedResponse)\n    };\n  } catch (error) {\n    console.error('Error:', error);\n    \n    return {\n      statusCode: 500,\n      headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Headers\": \"Content-Type,X-Amz-Date,Authorization,X-Api-Key\"\n      },\n      body: JSON.stringify({ \n        error: error.message,\n        stack: error.stack\n      })\n    };\n  }\n};",{
            "ApplicationId": { "Ref": "ApplicationId" }
          }]          }
              },
          "Runtime": "nodejs18.x",
          "Timeout": 30,
          "MemorySize": 256,
          "Layers": [
            "arn:aws:lambda:us-west-2:580247275435:layer:LambdaInsightsExtension:14"
          ]
        }
      },
      "EmailCollectionFunction": {
        "Type": "AWS::Lambda::Function",
        "Properties": {
          "FunctionName": "emailCollectionFunctionV2",
          "Handler": "index.handler",
          "Role": { "Fn::GetAtt": ["LambdaExecutionRole", "Arn"] },
          "Code": {
            "ZipFile": "const { SESClient, SendEmailCommand } = require('@aws-sdk/client-ses');\n\nexports.handler = async (event) => {\n  const headers = {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',\n    'Access-Control-Allow-Methods': 'OPTIONS,POST'\n  };\n\n  if (event.httpMethod === 'OPTIONS') {\n    return { statusCode: 200, headers, body: '' };\n  }\n\n  try {\n    const body = JSON.parse(event.body);\n    const { email, question, conversationId, chatHistory } = body;\n\n    console.log('Received request:', { email, question, conversationId, chatHistoryLength: chatHistory?.length || 0 });\n\n    if (!email || !question) {\n      throw new Error('Email and question are required');\n    }\n\n    const client = new SESClient({ region: 'us-west-2' });\n    const timestamp = new Date().toISOString();\n    const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Process chat history for email\n    const conversationText = chatHistory && chatHistory.length > 0 \n      ? chatHistory.map((msg, index) => {\n          const sender = msg.sentBy === 'USER' ? 'User' : 'Assistant';\n          const message = msg.message || '';\n          return `${index + 1}. ${sender}: ${message}`;\n        }).join('\\n\\n')\n      : 'No conversation history available';\n\n    // Create email content\n    const emailSubject = `Follow-up Request from ${email} - ${question.substring(0, 40)}...`;\n    const emailBody = `\nFollow-up Request Details:\n\nUser Email: ${email}\nOriginal Question: ${question}\nConversation ID: ${conversationId || 'N/A'}\nTimestamp: ${timestamp}\nRequest ID: ${requestId}\n\n--- FULL CONVERSATION HISTORY ---\n\n${conversationText}\n\n--- END OF CONVERSATION ---`;\n\n    // Log the full email content for debugging\n    console.log('===== EMAIL CONTENT START =====');\n    console.log('SUBJECT:', emailSubject);\n    console.log('BODY:', emailBody);\n    console.log('===== EMAIL CONTENT END =====');\n\n    const emailParams = {\n      Source: 'rajuhemanth456@gmail.com',\n      Destination: {\n        ToAddresses: ['rajuhemanth456@gmail.com'],\n\n      },\n      Message: {\n        Subject: {\n          Data: emailSubject,\n          Charset: 'UTF-8'\n        },\n        Body: {\n          Text: {\n            Data: emailBody,\n            Charset: 'UTF-8'\n          }\n        }\n      }\n    };\n\n    console.log('Sending email via SES:', { to: 'rajuhemanth456@gmail.com', subject: emailSubject });\n\n    const sesResponse = await client.send(new SendEmailCommand(emailParams));\n    console.log('SES Response:', JSON.stringify(sesResponse));\n\n    return {\n      statusCode: 200,\n      headers,\n      body: JSON.stringify({ success: true, requestId })\n    };\n  } catch (error) {\n    console.error('Error:', error);\n    return {\n      statusCode: 500,\n      headers,\n      body: JSON.stringify({ error: error.message })\n    };\n  }\n};"
          },
          "Runtime": "nodejs18.x",
          "Timeout": 30,
          "MemorySize": 256
        }
      },


      "LambdaExecutionRole": {
        "Type": "AWS::IAM::Role",
        "Properties": {
          "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "lambda.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          },
          "ManagedPolicyArns": [
            "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
          ],
          "Policies": [
            {
              "PolicyName": "QBusinessAccess",
              "PolicyDocument": {
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": [
                      "qbusiness:ChatSync",
                      "qbusiness:ListApplications"
                    ],
                    "Resource": "*"
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "ses:SendEmail",
                      "ses:SendRawEmail"
                    ],
                    "Resource": "*"
                  },
                  {
                    "Effect": "Allow",
                    "Action": [
                      "dynamodb:PutItem",
                      "dynamodb:GetItem",
                      "dynamodb:UpdateItem"
                    ],
                    "Resource": {
                      "Fn::GetAtt": ["ConversationTable", "Arn"]
                    }
                  }
                ]
              }
            }
          ]
        }
      },
      "AmazonQBusinessAPI": {
        "Type": "AWS::ApiGateway::RestApi",
        "Properties": {
          "Name": "AmazonQBusinessAPI",
          "Description": "API for Amazon Q Business Integration",
          "EndpointConfiguration": {
            "Types": ["REGIONAL"]
          }
        }
      },
      "ChatResource": {
        "Type": "AWS::ApiGateway::Resource",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ParentId": { "Fn::GetAtt": ["AmazonQBusinessAPI", "RootResourceId"] },
          "PathPart": "chat"
        }
      },
      "ChatMethod": {
        "Type": "AWS::ApiGateway::Method",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ResourceId": { "Ref": "ChatResource" },
          "HttpMethod": "POST",
          "AuthorizationType": "NONE",
          "Integration": {
            "Type": "AWS_PROXY",
            "IntegrationHttpMethod": "POST",
            "Uri": {
              "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${AmazonQBusinessFunction.Arn}/invocations"
            }
          }
        }
      },
      "ChatOptionsMethod": {
        "Type": "AWS::ApiGateway::Method",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ResourceId": { "Ref": "ChatResource" },
          "HttpMethod": "OPTIONS",
          "AuthorizationType": "NONE",
          "Integration": {
            "Type": "MOCK",
            "IntegrationResponses": [
              {
                "StatusCode": "200",
                "ResponseParameters": {
                  "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key'",
                  "method.response.header.Access-Control-Allow-Methods": "'OPTIONS,POST'",
                  "method.response.header.Access-Control-Allow-Origin": "'*'"
                },
                "ResponseTemplates": {
                  "application/json": ""
                }
              }
            ],
            "PassthroughBehavior": "WHEN_NO_MATCH",
            "RequestTemplates": {
              "application/json": "{\"statusCode\": 200}"
            }
          },
          "MethodResponses": [
            {
              "StatusCode": "200",
              "ResponseParameters": {
                "method.response.header.Access-Control-Allow-Headers": true,
                "method.response.header.Access-Control-Allow-Methods": true,
                "method.response.header.Access-Control-Allow-Origin": true
              }
            }
          ]
        }
      },
      "ConversationFunction": {
        "Type": "AWS::Lambda::Function",
        "Properties": {
          "FunctionName": "conversationFunctionV2",
          "Handler": "index.handler",
          "Role": { "Fn::GetAtt": ["LambdaExecutionRole", "Arn"] },
          "Code": {
            "ZipFile": "const { DynamoDBClient, GetItemCommand } = require('@aws-sdk/client-dynamodb');\n\nexports.handler = async (event) => {\n  const headers = {\n    'Access-Control-Allow-Origin': '*',\n    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key',\n    'Access-Control-Allow-Methods': 'OPTIONS,GET'\n  };\n\n  if (event.httpMethod === 'OPTIONS') {\n    return { statusCode: 200, headers, body: '' };\n  }\n\n  try {\n    const sessionId = event.queryStringParameters?.sessionId;\n    if (!sessionId) {\n      throw new Error('Session ID is required');\n    }\n\n    const dynamoClient = new DynamoDBClient({ region: 'us-west-2' });\n    const result = await dynamoClient.send(new GetItemCommand({\n      TableName: 'ChatConversations',\n      Key: { sessionId: { S: sessionId } }\n    }));\n\n    const conversation = result.Item ? {\n      conversationId: result.Item.conversationId?.S || '',\n      lastSystemMessageId: result.Item.lastSystemMessageId?.S || '',\n      chatHistory: result.Item.chatHistory?.S ? JSON.parse(result.Item.chatHistory.S) : [],\n      lastUpdated: result.Item.lastUpdated?.N || ''\n    } : null;\n\n    return {\n      statusCode: 200,\n      headers,\n      body: JSON.stringify({ conversation })\n    };\n  } catch (error) {\n    console.error('Error:', error);\n    return {\n      statusCode: 500,\n      headers,\n      body: JSON.stringify({ error: error.message })\n    };\n  }\n};"
          },
          "Runtime": "nodejs18.x",
          "Timeout": 30,
          "MemorySize": 256
        }
      },
      "EmailResource": {
        "Type": "AWS::ApiGateway::Resource",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ParentId": { "Fn::GetAtt": ["AmazonQBusinessAPI", "RootResourceId"] },
          "PathPart": "email"
        }
      },
      "ConversationResource": {
        "Type": "AWS::ApiGateway::Resource",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ParentId": { "Fn::GetAtt": ["AmazonQBusinessAPI", "RootResourceId"] },
          "PathPart": "conversation"
        }
      },
      "EmailMethod": {
        "Type": "AWS::ApiGateway::Method",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ResourceId": { "Ref": "EmailResource" },
          "HttpMethod": "POST",
          "AuthorizationType": "NONE",
          "Integration": {
            "Type": "AWS_PROXY",
            "IntegrationHttpMethod": "POST",
            "Uri": {
              "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${EmailCollectionFunction.Arn}/invocations"
            }
          }
        }
      },
      "EmailOptionsMethod": {
        "Type": "AWS::ApiGateway::Method",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ResourceId": { "Ref": "EmailResource" },
          "HttpMethod": "OPTIONS",
          "AuthorizationType": "NONE",
          "Integration": {
            "Type": "MOCK",
            "IntegrationResponses": [
              {
                "StatusCode": "200",
                "ResponseParameters": {
                  "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key'",
                  "method.response.header.Access-Control-Allow-Methods": "'OPTIONS,POST'",
                  "method.response.header.Access-Control-Allow-Origin": "'*'"
                },
                "ResponseTemplates": {
                  "application/json": ""
                }
              }
            ],
            "PassthroughBehavior": "WHEN_NO_MATCH",
            "RequestTemplates": {
              "application/json": "{\"statusCode\": 200}"
            }
          },
          "MethodResponses": [
            {
              "StatusCode": "200",
              "ResponseParameters": {
                "method.response.header.Access-Control-Allow-Headers": true,
                "method.response.header.Access-Control-Allow-Methods": true,
                "method.response.header.Access-Control-Allow-Origin": true
              }
            }
          ]
        }
      },
      "ConversationMethod": {
        "Type": "AWS::ApiGateway::Method",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ResourceId": { "Ref": "ConversationResource" },
          "HttpMethod": "GET",
          "AuthorizationType": "NONE",
          "Integration": {
            "Type": "AWS_PROXY",
            "IntegrationHttpMethod": "POST",
            "Uri": {
              "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConversationFunction.Arn}/invocations"
            }
          }
        }
      },
      "ConversationOptionsMethod": {
        "Type": "AWS::ApiGateway::Method",
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "ResourceId": { "Ref": "ConversationResource" },
          "HttpMethod": "OPTIONS",
          "AuthorizationType": "NONE",
          "Integration": {
            "Type": "MOCK",
            "IntegrationResponses": [
              {
                "StatusCode": "200",
                "ResponseParameters": {
                  "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key'",
                  "method.response.header.Access-Control-Allow-Methods": "'OPTIONS,GET'",
                  "method.response.header.Access-Control-Allow-Origin": "'*'"
                },
                "ResponseTemplates": {
                  "application/json": ""
                }
              }
            ],
            "PassthroughBehavior": "WHEN_NO_MATCH",
            "RequestTemplates": {
              "application/json": "{\"statusCode\": 200}"
            }
          },
          "MethodResponses": [
            {
              "StatusCode": "200",
              "ResponseParameters": {
                "method.response.header.Access-Control-Allow-Headers": true,
                "method.response.header.Access-Control-Allow-Methods": true,
                "method.response.header.Access-Control-Allow-Origin": true
              }
            }
          ]
        }
      },
      "ApiDeployment": {
        "Type": "AWS::ApiGateway::Deployment",
        "DependsOn": ["ChatMethod", "ChatOptionsMethod", "EmailMethod", "EmailOptionsMethod", "ConversationMethod", "ConversationOptionsMethod"],
        "Properties": {
          "RestApiId": { "Ref": "AmazonQBusinessAPI" },
          "StageName": "prod",
          "Description": "Deployment with email endpoint - v2"
        }
      },
      "ChatLambdaPermission": {
        "Type": "AWS::Lambda::Permission",
        "Properties": {
          "Action": "lambda:InvokeFunction",
          "FunctionName": { "Ref": "AmazonQBusinessFunction" },
          "Principal": "apigateway.amazonaws.com",
          "SourceArn": {
            "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${AmazonQBusinessAPI}/*/POST/chat"
          }
        }
      },
      "EmailLambdaPermission": {
        "Type": "AWS::Lambda::Permission",
        "Properties": {
          "Action": "lambda:InvokeFunction",
          "FunctionName": { "Ref": "EmailCollectionFunction" },
          "Principal": "apigateway.amazonaws.com",
          "SourceArn": {
            "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${AmazonQBusinessAPI}/*/POST/email"
          }
        }
      },
      "ConversationLambdaPermission": {
        "Type": "AWS::Lambda::Permission",
        "Properties": {
          "Action": "lambda:InvokeFunction",
          "FunctionName": { "Ref": "ConversationFunction" },
          "Principal": "apigateway.amazonaws.com",
          "SourceArn": {
            "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${AmazonQBusinessAPI}/*/GET/conversation"
          }
        }
      }
    },
    "Outputs": {
      "ApiEndpoint": {
        "Description": "API Gateway endpoint URL for Prod stage",
        "Value": {
          "Fn::Sub": "https://${AmazonQBusinessAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/"
        }
      },
      "ChatEndpoint": {
        "Description": "Chat API endpoint URL",
        "Value": {
          "Fn::Sub": "https://${AmazonQBusinessAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/chat"
        }
      },

      "ChatLambdaFunction": {
        "Description": "Chat Lambda Function ARN",
        "Value": { "Fn::GetAtt": ["AmazonQBusinessFunction", "Arn"] }
      },
      "EmailEndpoint": {
        "Description": "Email collection endpoint URL",
        "Value": {
          "Fn::Sub": "https://${AmazonQBusinessAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/email"
        }
      },
      "ConversationEndpoint": {
        "Description": "Conversation retrieval endpoint URL",
        "Value": {
          "Fn::Sub": "https://${AmazonQBusinessAPI}.execute-api.${AWS::Region}.amazonaws.com/prod/conversation"
        }
      }
    }
  }